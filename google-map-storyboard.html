<!--
The 'google-map-storyboard' renders a Google Map with 'google-map-scene' elements.

<b>Example</b> Add scenes to the map and traverse them linearly:

    <style>
      google-map-storyboard {
        height: 600px;
      }
    </style>
    <google-map-storyboard>
      <google-map-scene address="Sydney, Australia" zoom="5">This is Sydney!</google-map-scene>
      <google-map-scene address="Zurich, Switzerland"></google-map-scene>
    </google-map-storyboard>


@element google-map-storyboard
@homepage https://github.com/googlemaps/google-map-storyboard
-->
<!--
Fired when the storybord's google map is ready to be rendered.

@event google-map-storyboard-ready
-->
<link rel="import" href="bower_components/polymer/polymer.html">
<link rel="import" href="bower_components/google-apis/google-apis.html">
<link rel="import" href="google-map-scene.html">
<script src="TransitionManager.js"></script>

<polymer-element name="google-map-storyboard" attributes="apiKey current showMarkers disableDefaultUI">
<template>
  <style>

    :host {
      position: relative;
      display: block;
      height: 100%;
    }

    #map {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }

    #sceneMedia * {
      max-width: 100%;
      max-height: 100%;
    }

    #sceneMedia {
      display: inline-block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 300px;
      word-wrap: break-word;
      background-color: #ffffff;
      border: 1px solid black;
    }
    
    #image {
      display: inline-block;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    button {
      opacity: 0.5;
      font-size: 1.5em;
      outline: none;
      border-radius: 50%;
      background-color: #fff;
    }

    button:hover {
      opacity: 1;
    }
    
  </style>

  <google-maps-api apiKey="{{apiKey}}" version="3.exp" libraries="places,geometry" on-api-load="{{mapAPILoaded}}"></google-maps-api>

  <div id="map"></div>
  <div id="sceneMedia"></div>
  <div id="image"></div>

  <content id="scenes" select="google-map-scene" on-scene-changed="{{updateScene}}"></content>
</template>


<script>
(function() {
  Polymer({

    /**
     * Array of the google-map-scenes contained within the storyboard.
     * 
     * @property validScenes
     * @type Array.google-map-scene
     * @default null
     */
    validScenes: null,

    /**
     * The google map used in the storyboard.
     * 
     * @property map
     * @type google.maps.Map
     * @default null
     */
    map: null,

    /**
     * The Google Map API key. To obtain an API key, 
     * see developers.google.com/maps/documentation/javascript/tutorial#api_key.
     * 
     * @attribute apiKey
     * @type string
     * @default null
     */
    apiKey: null,

    publish: {
      /**
       * The id of the scene to be shown.
       * 
       * @attribute current
       * @type String
       * @default null
       */
      current: {value: null, reflect: true}
    },

    /**
     * If true, there is a marker shown at each scene.
     *
     * @attribute showMarkers
     * @type Boolean
     * @default true
     */
    showMarkers: true,

    /**
     * If true, removes the map's default UI controls.
     *
     * @attribute disableDefaultUI
     * @type Boolean
     * @default true
     */
    disableDefaultUI: true,

    /**
     * The current scene. Initialised to the first scene.
     *
     * @property currentScene
     * @type google-map-scene
     * @default null
     */
    currentScene: null,

    /**
     * The storyboard's transition and animation manager.
     * @property transitionManager
     * @type LinearAnimationManager
     * @default null
     */
    transitionManager: null,

    initializeMap: function() {
      if (!this.map) {
        var mapOptions = {
          center: this.currentScene.location,
          zoom: this.currentScene.zoom,
          disableDefaultUI: this.disableDefaultUI
        };
        this.map = new google.maps.Map(this.$.map, mapOptions);
        this.makeButton("prev", "Previous", "<", 
            google.maps.ControlPosition.LEFT_CENTER, this.getPrev);
        this.makeButton("next", "Next", ">", 
            google.maps.ControlPosition.RIGHT_CENTER, this.getNext);
        this.updateControls();
        this.transitionManager.setMap(this.map);
        this.showMarkersChanged();
        this.fire('google-map-storyboard-ready');
      }
    },

    updateContent: function() {
      var media = this.$.sceneMedia;
      var image = this.$.image
      var currentNode = this.currentScene.firstChild;
      if (currentNode instanceof HTMLImageElement) {
        image.innerHTML = currentNode.outerHTML;
        media.style.display = 'none';
        if (image.innerHTML) {
          image.style.display = 'inline-block';
        }
      }
      else {
        media.innerHTML = currentNode.textContent;
        image.style.display = 'none';
        if (media.innerHTML) {
          media.style.display = 'inline-block';
        }
      }
    },

    mapAPILoaded: function() {
      this.transitionManager = this.transitionManager || 
          new LinearAnimationManager();
      this.validScenes = this.validScenes || new google.maps.MVCArray();
      this.initializeScenes();
    },

    initializeScenes: function() {
      var allScenes = Array.prototype.slice.call(
          this.$.scenes.getDistributedNodes());
      this.validScenes.clear();
      this.currentScene = this.currentScene || allScenes[0];
      for (var i = 0, scene; scene = allScenes[i]; ++i) {
        scene.fireSceneChanged();
      }
    },

    updateScene: function(details) {
      // Return if the maps API hasn't loaded yet.
      if (!this.validScenes) return;
      var scene = details.srcElement;

      // If there is a new address to geocode, geocode it.
      if (!scene.ignoreAddress) this.geocodeScene(scene);
      // If this is the current scene, and it is invalid, find the replacement.
      if (scene === this.currentScene && isInvalidScene(scene)) {
        this.updateCurrentScene();
      }
      // TODO: Deal with scene removals.
      if (!isValidScene(scene)) return;

      var sceneIndex = this.validScenes.indexOf(scene);
      // If the scene is not already in validScenes, insert it.
      if (sceneIndex < 0) {
        sceneIndex = 0;
        var allScenes = Array.prototype.slice.call(
            this.$.scenes.getDistributedNodes());
        var nextValid = this.validScenes.getAt(0);
        for (var i = 0, nextScene; nextValid, nextScene = allScenes[i], 
            nextScene != scene; ++i) {
          if (this.validScenes.getAt(sceneIndex) === nextScene) {
            nextValid = this.validScenes.getAt(++sceneIndex);
          }
        }
        this.validScenes.insertAt(sceneIndex, scene);
        this.transitionManager.insertAt(sceneIndex, scene.location);
        if (this.showMarkers && scene.marker) scene.marker.setMap(this.map);
      } else {  // Otherwise the scene location has changed.
        this.transitionManager.setAt(sceneIndex, scene.location);
      }

      // If the map is initialized, update the markers and the controls.
      if (!this.map) {
        if (scene != this.currentScene) return;
        this.transitionManager.setCurrentIndex(sceneIndex, null);
        this.initializeMap();
        return;
      }
      this.updateControls();
    },

    geocodeScene: function(scene) {
      if (scene.ignoreAddress) return;
      var address = scene.address.valueOf();
      this.geocoder = this.geocoder || new google.maps.Geocoder();
      this.geocoder.geocode({address: address}, 
          function(place, status) {
        // Set ignore the address to true if the address hasn't changed.
        scene.ignoreAddress = (address === scene.address);
        if (status == google.maps.GeocoderStatus.OK) {
          scene.location = place[0].geometry.location;
        } else {
          scene.warn("Address %s failed to geocode due to %s. It " +
              "is shown at location %s.", address, status, scene.location);
        }
      }.bind(this));
    },

    /**
     * If the currentScene is invalid, finds the next (consecutive) non-invalid 
     * currentScene.  A scene is non-invalid if the address is being geocoded, 
     * or it has a valid location.
     *
     * @method updateCurrentScene
     */
    updateCurrentScene: function() {
      if (isValidScene(this.currentScene)) return;
      // Find a new current scene.
      var allScenes = Array.prototype.slice.call(
          this.$.scenes.getDistributedNodes());
      var index = allScenes.indexOf(this.currentScene);
      if (typeof index != 'number') index = 0;
      for (var i = 0; i < allScenes.length - 1; ++i) {
        var scene = allScenes[(i + index) % allScenes.length];
        if (!isInvalidScene(scene)) {
          this.currentScene = scene;
          scene.fireSceneChanged(false);
          return;
        }
      }
      this.warn("Warning! All scenes in this storyboard are currently invalid.");
    },

    warn: function() {
      console.warn.apply(console, Array.prototype.slice.call(arguments));
    },

    showMarkersChanged: function() {
      if (!this.map) return;
      var map = (this.showMarkers && this.map) || null;
      this.validScenes.forEach(function(scene) {
        if (scene.marker) scene.marker.setMap(map);
      });
    },

    disableDefaultUIChanged: function() {
      if (!this.map) return;
      this.map.setOptions({
        disableDefaultUI: this.disableDefaultUI
      });
    },

    currentSceneChanged: function() {
      this.current = this.currentScene.id;
    },

    currentChanged: function() {
      var scene = document.getElementById(this.current);
      if (!scene || scene.element.name != 'google-map-scene') {
        return;
      }
      if (this.validScenes && this.transitionManager) {
        var sceneIndex = this.validScenes.indexOf(scene);
        if (this.map) this.transitionManager.setCurrentIndex(sceneIndex, 
            this.activateScene.bind(this));
      }
      this.currentScene = scene;
    },

    getPrev: function() {
      if (this.transitionManager.hasPrev()) {
        this.transitionManager.prev(this.activateScene.bind(this));
        this.updateControls();
      }
    },

    getNext: function() {
      if (this.transitionManager.hasNext()) {
        this.transitionManager.next(this.activateScene.bind(this));
        this.updateControls();
      }
    },

    /**
     * If the index is changed, update the controls on the map.
     *
     * @method updateControls
     */
    updateControls: function() {
      if (!this.map) return;
      var control = this.map.controls[google.maps.ControlPosition.LEFT_CENTER];
      if (!this.transitionManager.hasPrev()) {
        this.prevButton = this.prevButton || control.removeAt(0);
      } else if (this.prevButton) {
        control.insertAt(0, this.prevButton);
        this.prevButton = null;
      }

      control = this.map.controls[google.maps.ControlPosition.RIGHT_CENTER];
      if (!this.transitionManager.hasNext()) {
        this.nextButton = this.nextButton || control.removeAt(0);
      } else if (this.nextButton) {
        control.insertAt(0, this.nextButton);
        this.nextButton = null;
      }
    },

    /**
     * Activate the upcoming scene.
     *
     * @method activateScene
     */
    activateScene: function() {
      if (this.map) {
        var scene = this.validScenes.getAt(this.transitionManager.getCurrentIndex());
        this.map.setZoom(scene.zoom);
        this.map.setCenter(scene.location);
        this.currentScene = scene;
        this.current = scene.id;
        this.updateContent();
      }
    },

    /**
     * Makes a button which is added to the map controls.
     *
     * @method makeButton
     * @param {String} id The button's id.
     * @param {String} title The button's title.
     * @param {String} text The text shown inside the button.
     * @param {google.map.ControlPosition} controlPosition Position on the map.
     * @param {Function} onClick The handler for a click event.
     */
    makeButton: function(id, title, text, controlPosition, onClick) {
      var button = document.createElement('button');
      button.id = id;
      button.title = title;
      var content = document.createTextNode(text);
      button.appendChild(content);
      google.maps.event.addDomListener(button, 'click', onClick.bind(this));
      this.map.controls[controlPosition].insertAt(0, button);
    }

  });

  /**
   * A scene is invalid if has an invalid address and invalid location.
   *
   * @method isInvalidScene
   * @param {google-map-scene} scene The scene to check if it is invalid or not.
   * @returns {Boolean} True if the scene has an invalid address and location.
   */
  function isInvalidScene(scene) {
    return (scene.ignoreAddress && !isLatLng(scene.location));
  }

  /**
   * A scene is valid and well defined if it has a valid location.
   *
   * @method isValidScene
   * @param {google-map-scene} scene The scene to check if it is valid or not.
   * @returns {Boolean} True if the scene has a valid location.
   */
  function isValidScene(scene) {
    return isLatLng(scene.location);
  }

  /**
   *
   * @method isLatLng
   * @param {Object} location The location to be checked.
   * @returns {Boolean} If true, the location is an instance of google.maps.LatLng
   */
  function isLatLng(location) {
    return location instanceof google.maps.LatLng;
  }

})();
</script>
</polymer-element>
